<?php
/* 
 * hook_menu
 */
   function es_webform_menu() {
   	
	$items = array();
  $items['dashboard'] = array(
      'page callback' => 'getDashboard',
      'type' => MENU_CALLBACK,
      //'access callback' => 'user_access',
      'access arguments' => array('access content'),
  );
  $items['product_edit'] = array(
      'page callback' => 'getProductEdit',
      'type' => MENU_CALLBACK,
      //'access callback' => 'user_access',
      'access arguments' => array('access content'),
  );    
  $items['product-add-manager'] = array(
      'page callback' => 'getAddManager',
      'type' => MENU_CALLBACK,
      //'access callback' => 'user_access',
      'access arguments' => array('access content'),
  );    
    return $items;
  }
	function getAddManager() {
		$output = "";
		return $output;
	}
	/*
	 * render dashboard
	 */
	function getDashboard() {
		$dashboard = new marketSpaceDashboard;
		$magento = new magento;
		$products = $dashboard->renderProductGrid();
		$output = "<ul class = 'marketspace_dashboard_grid'>";
    
		foreach($products as $product) {
		  $product_info = $product->product_id . "," . $product->set . "," . $product->type;
			$output .= "<li><a href='product_edit?info=" . urlencode($product_info)
				. "'>" . $product->name . "</a></li>";
		}
		$output = $output . "</ul>";
		return $output;
	}   

  /*
   * render product edit
   */
  function getProductEdit() {
    return drupal_get_form('product_edit_form');
    
  }  

function product_edit_form($form, &$form_state) {
    /*
     * get url params (encrypted) and
     * get webform that corresponds to the products
     * attribute set
     */
    $product = new magento_product;
    $product_edit = new product_edit;
    $magento = new magento;
    $magento_product_attributes = new magento_product_attributes;
    //$product_string = $magento->decryptText(urldecode($_GET["info"]));
    //watchdog('form check', 'get <pre>%get</pre> <br />post <pre>%post</pre> <br />form_state_check <pre>%form_state</pre><br /><pre>session
    //  %session</pre>',array('%get'=>print_r($_GET,true), '%post'=>print_r($_POST,true), '%session'=>print_r($_SESSION,true), '%form_state' => print_r($form_state,true)),WATCHDOG_NOTICE);
		
    $valid_form = true;
    /*
     * this done for ajax managed files. if you have
     * info then set info session. Otherwise get the info
     * session. If there is not one then $valid form will
     * be false so don't build form
     */
    if(isset($_GET["info"])) {
      variable_set('info', urldecode($_GET["info"]));
    } else {
      $valid_form = variable_get('info');
    }
    if(isset($_GET['q']) && $valid_form) {
      $product_string = urldecode(variable_get('info'));
      $product_data = explode(",", $product_string);
      
  		//get webform nid by attribute set attribute
  		$node_webform_id = $product->getWebformIdByAttributeSetAndType($product_data[1], $product_data[2]);
  		if(count($node_webform_id) == 1) { //make sure just one webform	TODO:- may want to have multiple
  			$product_id = $product_data[0];
  			$node = node_load($node_webform_id[0]->entity_id);
  			$webform = $node->webform["components"];
  			//get all additional attribute codes that need to be called in api
  			$additional_attributes = array();
        $stock_data_exists = false;
  			foreach($webform as $component) {
  				if(isset($component['extra']['magento_attribute_code']))	{
  					if($attribute_data = $magento_product_attributes->get_stored_magento_attribute_data($component['extra']['magento_attribute_code'])) {
  						$attribute = unserialize($attribute_data->data);
  						if(!($product->isCoreMagentoAttribute($attribute->attribute_code)))	{
  							$additional_attributes['additional_attributes'][] = $attribute->attribute_code;
  						}
  					}
  				} elseif(isset($component['extra']['inventory_attribute'])) {
  				  $stock_data_exists = true;
  				}
  			}
  			//get this products data from magento
  			//TODO: - needs to be a custom webservices that also checks ownership by a passed product id
      	$product_obj = $product->getProductById($product_data[0], $additional_attributes);
  			//put additional attributes on same level as core magento attributes. So easier to work with
  			//don't worry about multi select yet
  			if(isset($product_obj->additional_attributes)) {
	  			foreach($product_obj->additional_attributes as $attr) {
	  				$product_obj->{$attr->key} = $attr->value;
	  			}
				}
        if($stock_data_exists) {
            //get stock data TODO - must make a better function to get stock data
            //and perhaps an all inclusive function
            $stock_data_obj = $product->getProductStockData($product_data[0]);
            dpm($stock_data_obj);
            $product_obj->is_in_stock = $stock_data_obj[0]->is_in_stock;
            $product_obj->qty = $stock_data_obj[0]->qty;
          }
        $form['product-edit-form'] = array(
          '#markup' => '<div>' . t('Product Edit Form')
            . '</div>',
          '#attached' => array(
            'js' => array(drupal_get_path('module', 'es_webform') . '/js/accordion_tabs.js'),
            	array(drupal_get_path('module', 'es_webform'), '/js/jquery-ui.js'),
            'css' => array(drupal_get_path('module', 'es_webform') . '/css/es_webform.css'),
          ),
        );
  			$form['view-product'] = array(
  				'#markup' => t('<p><a href="@link" target="_blank">View Product</a></p>', array('@link' => $product->base_url . $product_obj->url_path)),
  			);
  			//set product id and edit node id - for processing the form for magento
  			$form['product_id'] = array('#type'=>'hidden', '#value' => $product_data[0]);
  			$form['product_edit_node_id'] = array('#type'=>'hidden', '#value' => $node_webform_id[0]->entity_id);
				isset($form_state['active_fieldset_name']) ? '' : $form_state['active_fieldset_name'] = ''; //start a field set as uncollpased if name is set in this variable
        $custom_magento_components = array("categories", "custom_options", "images");
        //display the form components accordion
        $current_fieldset = ""; //all components must be in a fieldset   
        dpm($product_obj);
        foreach($webform as $component) {
          if(isset($component['extra']['magento_attribute_code'])) {
            if($attribute_data = $magento_product_attributes->get_stored_magento_attribute_data($component['extra']['magento_attribute_code'])) {
              $attribute = unserialize($attribute_data->data);
              //add element to form with data prepopultated
              $form[$current_fieldset][$attribute->attribute_code] = $product_edit->create_attribute_input($attribute, $form_state, $component, $product_obj);
            }
					} elseif(isset($component['extra']['inventory_attribute'])) {
					  $inventory_type = 'select';
            if(in_array($component['extra']['inventory_attribute'], array('qty'))) {
					    $inventory_type = 'textfield';
					  }
						$form[$current_fieldset][$component['extra']['inventory_attribute']] = array(
						    '#type' => $inventory_type,
						    '#title' => $component['name'],
						    '#required' => ($component['mandatory']) ? TRUE : FALSE,
						    '#description' => isset($component['extra']['description']) ? $component['extra']['description'] : '',
						    '#default_value' => isset($product_obj->{$component['extra']['inventory_attribute']}) ? 
						      $product_obj->{$component['extra']['inventory_attribute']} : '',
						  );
              //drupal_set_message($product_obj->{$component['extra']['inventory_attribute']} . "stock data " . $component['extra']['inventory_attribute'], 'notice');
            if($inventory_type == 'select') {
              $form[$current_fieldset][$component['extra']['inventory_attribute']]['#options'] = array(1 => 'In Stock', 0 => 'Out Of Stock');
            }
  				} elseif(isset($component['extra']['magento_attribute_code_name'])) {
  					if($component['extra']['magento_attribute_code_name'] == 'categories') {
  						$category = new magento_product_category;
  						$value_path = "";
  				    $the_path = array_searchRecursive("Array", $component, $strict=false, $path=array(), $value_path);
  				    $checked_categories = explode(",",$value_path);
  						$selected_categories = array();
  						foreach($product_obj->{$component['extra']['magento_attribute_code_name']} as $key=>$cat) {
  							$selected_categories[$cat] = 1;
  						}
  						//TODO use a different more abstract function for category rendering - this is messy
  						//categories in input formstate are at: submitted[profile_information_header][venue_sweets_categories][categories]
  				    $categories = $category->get_categories($checked_categories, $excluded_categories = array(2));
  						$category->create_category_checkboxes($categories, $form, $component, true, $selected_categories);
  						$form[$current_fieldset]['categories'] = $form['categories']; //should probably clean this up so we can avoid the unset and this
  						unset($form['categories']);
  					} elseif($component['extra']['magento_attribute_code_name'] == 'product_image') {
                $magento_media = new magento_media;
                $images = $magento_media->get_all_media($product_id);
                //tile all images with delete and edit ajax buttons
                $form[$current_fieldset]['image_manager'] = array(
                  '#type' => 'container',
                  '#tree' => TRUE,
                );
                $image_count = 0;
                foreach($images as $key=>$image) {
                  $magento_media->render_image_manager_element($form, $key, $image, $current_fieldset, true);
                  $image_count = $key;
                }
                //make add button
                $magento_media->render_image_manager_element($form, ($image_count+1), null, $current_fieldset, false);
                //have an add image button
                //$form[$current_fieldset][] = $magento_media->render_marketspace_image_input($images[0]->url);
            } elseif($component['extra']['magento_attribute_code_name'] == 'custom_options') {
        				$product_custom_options = new product_custom_options;
                $magento_custom_options = new magento_custom_options;
								$options = $product_custom_options->getAllCustomOptions();
								$form[$current_fieldset]['#tree'] = TRUE;
								$form[$current_fieldset]['#prefix'] = $form[$current_fieldset]['#prefix'] . "<div id='custom-options-wrapper'>";
								$form[$current_fieldset]['#suffix'] = $form[$current_fieldset]['#suffix'] . "</div>";
								
								$custom_options_count = 0;
								//make api call
								$magento_product_options = $magento_custom_options->get_product_custom_options($product_id);
								//then add all magento options to new options count
								//STEP 1: add existing magento custom options
								if(count($magento_product_options) > 0) {
  								foreach($magento_product_options as $key=>$option) { //option_id, title, type, sort_order, is_require
  								  $this_option = $magento_custom_options->get_custom_option_info($option->option_id);
                    $this_option->id = $option->option_id;
                    //dpm($this_option); //additional_fields[0]->price, price_type, sku, max_characters
                    //@TODO- put a delete checkbox instead of a delete button for existing magento options
                    //gray out option on click and say marked for delete save to apply changes
  								  $form[$current_fieldset][$key] = $product_custom_options->renderOptionInfoForm($options, $key, $form_state, $this_option); 
  								}
                }
								//check for new added options but not sent to magento
								if(isset($form_state['input']['custom_options'])) { //add pending add options to magento options
									$custom_options_count = $custom_options_count + count($form_state['input']['custom_options']);
								} 
			
								//STEP 2: Newly added custom options in drupal that are in form_state
								// but not saved in magento - excludes the option that appears after clicking add (Step 3)
								if(isset($form_state['input']['custom_options'])) {
									foreach($form_state['input']['custom_options'] as $key=>$option) {
										$form[$current_fieldset][$key] = $product_custom_options->renderOptionInfoForm($options, $key, $form_state, null);
									}
								}
								//Step 3: display new custom option add element if 
								//add custom option button clicked if so 
								//set custom option count to one to reflect the need for an extra option
								if(isset($form_state['triggering_element']['#value'])) {
  							  if ($form_state['triggering_element']['#value'] == 'Add Custom Option') {
  							    $form[$current_fieldset][($custom_options_count)] = $product_custom_options->renderOptionInfoForm($options, $custom_options_count, $form_state, null);
  									//watchdog('form info', '%num_count count and <pre>%form</pre><br />',array('%form' => print_r($form_state,true), '%num_count'=>$custom_options_count),WATCHDOG_NOTICE);
  							  }
                }
							  $form[$current_fieldset]['add_custom_option'] = array(
							    '#type' => 'button',
							    '#value' => t('Add Custom Option'),
							    '#ajax' => array(
							    	'method' => 'before',
							      'callback' => 'add_custom_option',//'ajax_example_add_more_callback', es_webform_add_new add_custom_option
							      'wrapper' => 'edit-custom-options-add-custom-option',//'edit-custom-options-' . ($custom_options_count),
							    ),
							    '#prefix' => '<!--<attributes><id>'. $custom_options_count . '</id></attributes>-->',
							  );
						}
          } else { //not a regular attribute could be categories, custom attributes, images etc
          	if($component['type'] != 'pagebreak') {
  						if($component['type'] == 'markup') {
  							$form[$current_fieldset][$component['form_key']] = array(
  								'#markup' => t('!value', array('!value'=>$component['value'])), //$component['form_key']['value'];
  								'#type' => $component['type'],
  							);
  						} elseif($component['type'] == 'fieldset') {
  							if($form_state['active_fieldset_name'] == $component['form_key']) {
									$tab_state_class = ' product-edit-group-marketspace-tab-active';
								} else {
									$tab_state_class = '';
								}
  		          $form[$component['form_key']] = array(
  		          	'#type' => $component['type'],
  	            	'#title' => '',
  	            	'#prefix' => "<h2 class='product-edit-group-marketspace-tab" . $tab_state_class . "'>" . $component['name'] . "</h2><div class='product-edit-group-marketspace'>",
  	            	'#suffix' => "</div>",
  	          	);
							
  							$current_fieldset = $component['form_key'];
  						}
  					}
          }
        }
        //watchdog('form complete', '%num_count count and <pre>%form</pre><br />',array('%form' => print_r($form_state,true), '%num_count'=>$custom_options_count),WATCHDOG_NOTICE);
        $form['submit'] = array(
          '#type' => 'submit',
          '#value' => t('Submit'),
        );
				
      	return $form;
      } elseif(count($node_webform_id) > 1) {
      	drupal_set_message(t('Too many forms matching this product Error: more than one attribute set'), 'error');
      } else {
      	drupal_set_message(t('No forms matching this product Error: incorrect or non existent attribute set'), 'error');
      }
   }
}
/**
 * Submit handler for the "add-one-more" button.
 *
 * Increments the max counter and causes a rebuild.
 * 
 * WARNING this will fire when other unrelated ajax
 * elements are triggered. Therefore add the check for
 * _triggering_element_value == "Add one more" so we
 * we only increment num_names by 1 if the add more
 * button is clicked
 */
function add_custom_option($form, &$form_state) {
	if(isset($form_state['triggering_element'])) {
		$form_state['active_fieldset_name'] = $form_state['triggering_element']['#array_parents'][0];
		//add custom option
		if($form_state['triggering_element']['#value'] == "Add Custom Option") {
		  if(isset($form_state['input']['custom_options'])) {
		    $option_num = count($form_state['input']['custom_options']);
        watchdog('custom option add HIT!', '%numcount attr id <pre>%attr_id</pre> : xml <pre>%xml</pre> ', array('%numcount'=>$option_num,
        '%xml' => print_r($form_state,true), '%attr_id' => "no atts"),WATCHDOG_NOTICE);
  		  $form_state['rebuild'] = TRUE;
  		  return $form['custom_options'][$option_num];
      } elseif(isset($form_state['values']['custom_options'])) {
        $option_num = count($form_state['values']['custom_options']);
        watchdog('custom option add (values) hit!', '%numcount attr id <pre>%attr_id</pre> : xml <pre>%xml</pre> ', array('%numcount'=>$option_num,
        '%xml' => print_r($form,true), '%attr_id' => "no atts"),WATCHDOG_NOTICE);
        $form_state['rebuild'] = TRUE;
        return $form['custom_options'][0];        
      }
		//delete custom option
		} elseif($form_state['triggering_element']['#value'] == "Delete Custom Option") {
		  //isset($form_state['num_custom_options']) ? $form_state['num_custom_options'] =  $form_state['num_custom_options'] + 1: $form_state['num_custom_options'] = 1; //TODO:-this is undefined initially so may want conditional
			$xml = str_replace(array('<!--','-->'),'',$form_state['triggering_element']['#prefix']);
			$attributes = simplexml_load_string($xml);		  
		  unset($form_state['input']['custom_options'][(int)$attributes->id]);
			$form_state['input']['custom_options'] = array_values($form_state['input']['custom_options']);
		  watchdog('custom option delete HIT!', '%numcount attr id <pre>%attr_id</pre> : xml <pre>%xml</pre> ', array('%numcount'=>4,
	  	'%xml' => print_r($form_state,true), '%attr_id' => print_r($attributes,true)),WATCHDOG_NOTICE);
		  $form_state['rebuild'] = TRUE;
		}
	}
}
/*
 * callback for type select
 * inserts the appropriate custom option
 * template when changed
 */
 function getCustomOptionsTypeTemplate($form, $form_state) {
	$xml = str_replace(array('<!--','-->'),'',$form_state['triggering_element']['#prefix']);
	$attributes = simplexml_load_string($xml);	
	//watchdog('custom option ajax callback', 'attr id %attr_id : values for xmlstring %xml_string attributes arr <pre>%attributes</pre> xml <pre>%xml</pre> <br />form check <pre>%form</pre>', array('%xml'=>print_r($form_state,true)
	//	, '%form' => print_r($form, true), '%xml_string'=>$xml, '%attributes' => print_r($attributes,true)
	//	,'%attr_id'=>((int)$attributes->id)),WATCHDOG_NOTICE);
  return $form['custom_options'][((int)$attributes->id)]['values']; 	
 }
/*
 * call back for option value add
 * for select, multiselect, checkbox
 * and radio. 
 * 
 * Add - we need to get the parent and that is 
 * passed from the add button in xml. Then get
 * the next index (count is 0 if no elements)
 * by counting elements of the values array for
 * the given parent
 * 
 * These callbacks are all about reloading parts of the form
 * so ajax functions really never really need to be that
 * long most work actually happens in the form building
 * code
 */
function option_value_callback($form, &$form_state) {
	//watchdog('ajax attempted', '%num_count count and <pre>%form</pre><br />',array('%form' => print_r($form_state,true), '%num_count'=>22 . ' val ' . 1),WATCHDOG_NOTICE);
  if(isset($form_state['triggering_element'])) {
    if($form_state['triggering_element']['#value'] == "Add Value") {
      //$option_num = count($form_state['input']['custom_options']);
      //we will always add to an existing option type option so
      //have to say $option_num - 1 to get the proper index
      //$form_state['rebuild'] = TRUE;
      $xml = str_replace(array('<!--','-->'),'',$form_state['triggering_element']['#prefix']);
      $attributes = simplexml_load_string($xml);
			if(isset($form_state['input']['custom_options'][(int)$attributes->parent_id]['values'])) {
				$value_num = count($form_state['input']['custom_options'][(int)$attributes->parent_id]['values']);
			} else {
				$value_num = 0;
			}
      //watchdog('option value callback add value', '%num_count count and <pre>%form</pre><br />',array('%form' => print_r($form_state,true), '%num_count'=>$attributes->parent_id . ' val ' . $value_num),WATCHDOG_NOTICE);
      return $form['custom_options'][(int)$attributes->parent_id]['values'][$value_num];
    //delete custom option
    }  elseif($form_state['triggering_element']['#value'] == "Delete") {
      //isset($form_state['num_custom_options']) ? $form_state['num_custom_options'] =  $form_state['num_custom_options'] + 1: $form_state['num_custom_options'] = 1; //TODO:-this is undefined initially so may want conditional
      $xml = str_replace(array('<!--','-->'),'',$form_state['triggering_element']['#prefix']);
      $attributes = simplexml_load_string($xml);
      watchdog('custom option delete HIT!', '%numcount attr id <pre>%attr_id</pre> : xml <pre>%xml</pre> ', array('%numcount'=>3,
      '%xml' => print_r($form_state,true), '%attr_id' => print_r($attributes,true)),WATCHDOG_NOTICE);
      //$form_state['rebuild'] = TRUE;
			return $form['custom_options'][(int)$attributes->parent_id]['values'];//[(int)$attributes->id];
    }
  }
  
}
/*
 * ajax functions for image edit, delete,
 * and add. These have to be seperated from magento
 * attribute operations since the api for product
 * create does not include them
 * TODO: - will add similar callback for upsells, 
 * custom options, and bundled products.
 */
function edit_marketspace_image_callback($form, &$form_state) {
  watchdog('image-edit', "form state parent %parent ___ form <pre>%form_state</pre>", array("form_state" => print_r($form_state,true), '%parent' => $form_state['triggering_element']['#array_parents'][0]),WATCHDOG_NOTICE);
  $magento_media = new magento_media;
  if(isset($form_state['triggering_element']['#prefix']) && isset($form_state['input']['product_id'])) {
    $product_id = $form_state['input']['product_id'];
    $xml = str_replace(array('<!--','-->'),'',$form_state['triggering_element']['#prefix']);
    $image_attributes = simplexml_load_string($xml); 
    if($form_state['triggering_element']['#value'] == "Edit") {
        $data = $magento_media->get_marketspace_media_data($form_state['input'], $image_attributes, false);
        $image_data = $magento_media->get_magento_media_data($data);
        $result = $magento_media->update_media_by_product_id($product_id, $image_data);
    } elseif($form_state['triggering_element']['#value'] == "Delete") {
      watchdog('image-edit', "INFO <pre>%form_state</pre> <br />result ", array("form_state" => print_r($image_attributes,true)),WATCHDOG_NOTICE);
      $result = $magento_media->remove_media_by_product_id($product_id, $image_attributes->file);
    } elseif($form_state['triggering_element']['#value'] == "Add") {
        $data = $magento_media->get_marketspace_media_data($form_state['input'], $image_attributes, true);
        $image_data = $magento_media->get_magento_media_data($data);
        $result = $magento_media->create_media($product_id, $image_data);
    }
  }
  return null;
}

/*
 * send product edit data to magento
 */
function product_edit_form_submit(&$form, &$form_state) {
	$product = new magento_product;
	$product_custom_options = new product_custom_options;
  
  //there was no good way so I just look for qty or is_in_stock could possibly search
  //through values array
  //TODO - search through values array and look for stock attribute in key
  //TODO you can apparently blindly pass the values array without magento giving a problem
  //test for the performance hit
  if(isset($form_state['values']['qty']) || isset($form_state['values']['is_in_stock'])) {
    $result = $product->updateProductStockData($form_state['input']['product_id'], $form_state['values']);
  } 
	if(isset($form_state['values']['custom_options'])) {
		$product_custom_options->updateCustomOptions($form_state['values']);
	}
	
	 // echo "<pre>" . print_r($form_state,true) . "</pre>";
  //die;
  //drupal_set_message('form_state: alan ' . print_r($form_state,true), 'notice');
	$data = $product->getProductDataArray($form_state);
	
	$result = $product->updateProduct($form_state['input']['product_id'], $data);
	//$stockData = $product->getProductStockDataArray($form_state);
	//$resultStock = $product->updateProductStockData($form_state['input']['product_id'], $stockData)
 
  /*
   * CUSTOM OPTIONS
   */
	//check for custom options save new completed ones and update current ones
	if($result) {
		drupal_set_message(t("Product has been updated."), 'notice');
	} else {
		drupal_set_message(t("Product update failed."), 'error');
	}
 	//echo "<pre>" . print_r($data,true) . "</pre>";
	//die;
  //$form_state['redirect'] = 'user';
}
/**
 * Implements hook_webform_select_options_info().
 */
/*function es_webform_webform_select_options_info() {
  $options['payment_method'] = array(
    'title' => t('Payment methods'),
    'options callback' => 'payment_method_options',
  );
  $options['payment_status'] = array(
    'title' => t('Payment statuses'),
    'options callback' => 'payment_status_options',
  );

  return $options;
}*/

/**
 * Implements hook_webform_component_info().
 */
function es_webform_webform_component_info() {
  $components['es_webform'] = array(
    'label' => t('Magento Attribute'),
    'description' => t('Lets users pay before being able to submit a webform.'),
    'features' => array(
      'default_value' => FALSE,
      'required' => TRUE,
    ),
    'file' => 'es_webform.webform.inc',
  );

  return $components;
}

/* add js and css 
 * see webform.module line 1857 webform_client_form
 * function for a good example
 * any webform will be webform_client_form_(nid)
 * so webform_client_form_2
 */
function es_webform_form_alter(&$form, $form_state, $form_id){
  if($form_id == "webform_component_edit_form") {
    //$form['validation']['#disabled'] = TRUE;
    //$form['validation']['#collapsed'] = TRUE;
  }
  if($form_id == "webform_client_form_2") {
    $form['#attached'] = array(
     'js' => array(drupal_get_path('module', 'es_category') . '/js/toggle_category.js'),
     'css' => array(drupal_get_path('module', 'es_category') . '/css/custom_components.css'),
    );
   }
}